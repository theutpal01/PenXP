require("dotenv").config();
const crypto = require("crypto");
const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");
const validator = require("validator");
const User = require("../models/User");

const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET;

const transporter = nodemailer.createTransport({
	service: "Gmail",
	host: "smtp.gmail.com",
	port: 465,
	secure: true,
	auth: {
		user: process.env.SMTP_USER,
		pass: process.env.SMTP_PASS,
	},
});

const sendVerificationEmail = async (email, token) => {
	const verificationLink = `${process.env.DOMAIN_NAME}/auth/verify?token=${token}`;

	const mailOptions = {
		from: `"PenXP" <${process.env.SMTP_USER}>`,
		to: email,
		subject: "Verify Your Email for PenXP",
		html: `
  <div style="min-width: 100%; margin: 0; padding: 20px; background-color: #FFFFFF; font-family: Arial, sans-serif;">
    <table role="presentation" width="100%" cellpadding="0" cellspacing="0" border="0" align="center" style="background-color: #FFFFFF;">
      <tr>
        <td align="center">
          <table role="presentation" width="600" cellpadding="0" cellspacing="0" style="background-color: #FFFFFF; border: 1px solid #EBEBEB; border-radius: 3px; overflow: hidden; padding: 20px;">
            <tr>
              <td align="left">
                <img src="https://res.cloudinary.com/thetestproject/image/upload/v1738677586/logo_epcsma.png"
                  width="42" height="42" alt="Company Logo" style="display: inline; margin: 0 auto;" />
              </td>
            </tr>
            <tr>
              <td align="left">
                <h1 style="font-size: 24px; font-weight: bold; color: #141414; text-align: left; margin-bottom: 10px;">
                  Confirm Your Account
                </h1>
                <p style="font-size: 15px; color: #141414; text-align: left; padding: 10px 0px;">
                  Please click the button below to confirm your email address and finish setting up your account.
                </p>
                <a href="${verificationLink}" style="display: inline-block; background-color: #0666EB; color: #FFFFFF;
                  padding: 10px 20px; border-radius: 40px; text-decoration: none; font-weight: bold;">
                  Confirm Email
                </a>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>
`,
	};

	await transporter.sendMail(mailOptions);
};

const sendResetEmail = async (email, token) => {
	const resetPasswordLink = `${process.env.DOMAIN_NAME}/auth/reset-password?token=${token}`;

	const mailOptions = {
		from: `"PenXP" <${process.env.SMTP_USER}>`,
		to: email,
		subject: "Reset Password",
		html: `<div style="min-width: 100%; margin: 0; padding: 20px; background-color: #FFFFFF; font-family: Arial, sans-serif;">
    <table role="presentation" width="100%" cellpadding="0" cellspacing="0" border="0" align="center" style="background-color: #FFFFFF;">
      <tr>
        <td align="center">
          <table role="presentation" width="600" cellpadding="0" cellspacing="0" 
            style="background-color: #FFFFFF; border: 1px solid #EBEBEB; border-radius: 3px; overflow: hidden; padding: 20px;">
            <tr>
              <td align="left">
                <img src="https://res.cloudinary.com/thetestproject/image/upload/v1738677586/logo_epcsma.png"
                  width="42" height="42" alt="Company Logo" style="display: inline; margin: 0 auto;" />
              </td>
            </tr>
            <tr>
              <td align="left">
                <h1 style="font-size: 24px; font-weight: bold; color: #141414; text-align: left; margin-bottom: 10px;">
                  Reset your password
                </h1>
                <p style="font-size: 15px; color: #141414; text-align: left; padding: 10px 0px;">
                  Please click the button below to reset your password. Ignore this email if this request is not generated by you.
                </p>
                <a href="${resetPasswordLink}" 
                  style="display: inline-block; background-color: #0666EB; color: #FFFFFF; padding: 10px 20px; 
                  border-radius: 40px; text-decoration: none; font-weight: bold;">
                  Reset Password
                </a>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>
`,
	};

	await transporter.sendMail(mailOptions);
};

router.get("/verify", async (req, res) => {
	try {
		const { token } = req.query;
		console.log(token);
		if (!token)
			return res.status(400).json({ error: "Verification token is missing." });

		const user = await User.findOne({ verificationToken: token });
		if (!user)
			return res.status(400).json({ error: "Invalid verification token." });

		user.isVerified = true;
		user.verificationToken = null;
		await user.save();

		res.json({ message: "Email verified successfully. You can now log in." });
	} catch (err) {
		res.status(500).json({ error: err.message });
	}
});

router.post("/forgot-password", async (req, res) => {
	try {
		const { email } = req.body;

		const user = await User.findOne({ email });
		if (!user) return res.status(404).json({ message: "User not found" });

		const resetToken = crypto.randomBytes(32).toString("hex");

		user.resetPasswordToken = resetToken;
		user.resetPasswordExpires = Date.now() + 7200000; // 2 hour expiry
		await user.save();

		await sendResetEmail(user.email, resetToken);

		res.json({ message: "Password reset email sent!" });
	} catch (error) {
		res.status(500).json({ message: "Server error" });
	}
});

router.post("/reset-password/:token", async (req, res) => {
	try {
		const { token } = req.params;
		const { newPassword } = req.body;

		const user = await User.findOne({
			resetPasswordToken: token,
			resetPasswordExpires: { $gt: Date.now() }, // Token should not be expired
		});

		if (!user) {
			return res.status(400).json({ message: "Invalid or expired token" });
		}

		const salt = await bcrypt.genSalt(10);
		const hashedPassword = await bcrypt.hash(newPassword, salt);

		user.password = hashedPassword;
		user.resetPasswordToken = undefined;
		user.resetPasswordExpires = undefined;
		await user.save();

		res.json({ message: "Password reset successful. You can now log in!" });
	} catch (error) {
		res.status(500).json({ message: "Server error" });
	}
});

/**
 * Register User (Now Includes First & Last Name)
 */
router.post("/register", async (req, res) => {
	try {
		const { firstName, lastName, username, email, password, isOAuthUser } =
			req.body;
		if (
			!firstName ||
			!lastName ||
			!username ||
			!email ||
			(!isOAuthUser && !password)
		) {
			return res.status(400).json({
				error:
					"First name, last name, username, email, and password (if not OAuth) are required.",
			});
		}

		if (!validator.isEmail(email)) {
			return res.status(400).json({ error: "Invalid email format." });
		}

		const existingUser = await User.findOne({ $or: [{ email }, { username }] });
		if (existingUser) {
			return res
				.status(400)
				.json({ error: "Username or email already exists." });
		}
		const salt = await bcrypt.genSalt(10);
		const verificationToken = crypto.randomBytes(32).toString("hex");

		const newUser = new User({
			firstName,
			lastName,
			username,
			email,
			isOAuthUser,
			password: isOAuthUser
				? undefined
				: await bcrypt.hash(password.trim(), salt),
			profileCompleted: false, // User still needs to complete optional details
			verificationToken,
			isVerified: false,
		});

		await newUser.save();
		await sendVerificationEmail(email, verificationToken);

		res.status(201).json({
			message: "User registered. Please verify your email.",
			userId: newUser._id,
		});
	} catch (err) {
		res.status(500).json({ error: err.message });
	}
});

/**
 * Complete Optional Profile
 */
router.post("/complete-profile", async (req, res) => {
	try {
		const { userId, bio, website, socialLinks } = req.body;

		const user = await User.findById(userId);
		if (!user) return res.status(404).json({ error: "User not found." });
		if (user.profileCompleted)
			return res.status(400).json({ error: "Profile is already completed." });

		user.bio = bio;
		user.website = website;
		user.socialLinks = socialLinks;
		user.profileCompleted = true;

		await user.save();
		res.json({ message: "Profile completed successfully.", user });
	} catch (err) {
		res.status(500).json({ error: err.message });
	}
});

/**
 * âœ… User Login & Token Generation
 */
router.post("/login", async (req, res) => {
	try {
		console.log(JWT_SECRET);

		const { email, password } = req.body;
		if (!email || !password) {
			return res
				.status(400)
				.json({ error: "Email and password are required." });
		}

		const user = await User.findOne({ email });
		console.log(user);
		if (!user || user.isOAuthUser) {
			return res
				.status(400)
				.json({ error: "Invalid credentials or use OAuth login." });
		}

		const isMatch = await bcrypt.compare(password.trim(), user.password.trim());
		console.log("Password:", password); // Log the plain password
		console.log("Hashed Password:", user.password, isMatch); // Log the stored hash

		if (!isMatch)
			return res.status(400).json({ error: "Invalid credentials." });

		const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
			expiresIn: "1d",
		});

		res.json({
			token,
			user: {
				username: user.username,
				email: user.email,
				profileCompleted: user.profileCompleted,
			},
		});
	} catch (err) {
		res.status(500).json({ error: err.message });
	}
});

/**
 * OAuth Login (Google)
 */
router.post("/oauth-login", async (req, res) => {
	try {
		const { email, username, firstName, lastName } = req.body;
		if (!email || !username || !firstName || !lastName) {
			return res.status(400).json({
				error:
					"Email, username, first name, and last name are required for OAuth login.",
			});
		}

		let user = await User.findOne({ email });

		if (!user) {
			user = new User({
				email,
				username,
				firstName,
				lastName,
				isOAuthUser: true,
				profileCompleted: false,
			});
			await user.save();
		}

		const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
			expiresIn: "1d",
		});
		res.json({
			token,
			user: {
				username: user.username,
				email: user.email,
				profileCompleted: user.profileCompleted,
			},
		});
	} catch (err) {
		res.status(500).json({ error: err.message });
	}
});

router.get("/profile", async (req, res) => {
	try {
		// Extract the token from the Authorization header
		const token = req.headers.authorization?.split(" ")[1];

		if (!token) {
			return res
				.status(401)
				.json({ error: "Unauthorized. No token provided." });
		}

		// Verify the JWT token
		const decoded = jwt.verify(token, JWT_SECRET);
		const userId = decoded.userId;

		// Find the user in the database
		const user = await User.findById(userId).select(
			"-password -resetPasswordToken -resetPasswordExpires -verificationToken"
		);

		if (!user) {
			return res.status(404).json({ error: "User not found." });
		}

		// Return user profile data
		res.json({
			user: {
				id: user._id,
				firstName: user.firstName,
				lastName: user.lastName,
				username: user.username,
				email: user.email,
				profileCompleted: user.profileCompleted,
				bio: user.bio || "",
				website: user.website || "",
				socialLinks: user.socialLinks || {},
				isOAuthUser: user.isOAuthUser,
				isVerified: user.isVerified,
				createdAt: user.createdAt,
			},
		});
	} catch (err) {
		res.status(500).json({ error: "Server error: " + err.message });
	}
});

module.exports = router;
